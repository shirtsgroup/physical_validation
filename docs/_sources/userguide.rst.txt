Introduction
============

Advances in recent years have made molecular dynamics (MD) simulations a
powerful tool in molecular-level research, allowing the prediction of
experimental observables in the study of systems such as proteins, drug
targets or membranes. The quality of any prediction based on MD results
will, however, strongly depend on the validity of underlying physical
assumptions.

This package is intended to help detecting (sometimes hard-to-spot)
unphysical behavior of simulations, which may have statistically important
influence on their results. It is thereby part of a two-fold approach to
increase the robustness of molecular simulations.

Firstly, it empowers users of MD programs to test the physical validity on
their respective systems and setups. The tests thereby range from simple
post-processing analysis to more involved tests requiring additional
simulations. These tests can be shown to significantly increase the
reliability of MD simulations by catching a number of common simulation
errors violating physical assumptions, such as non-conservative
integrators, deviating from the Boltzmann ensemble, or lack of ergodicity
between degrees of freedom. To render the usage as easy as possible,
parsers for several popular MD program output formats are provided.

Secondly, it can be integrated in MD code testing environements. While
unphysical behavior can be due to poor or incompatible choices of
parameters by the user, it can just as well originate in coding errors
within the program. Physical validation tests can be integrated in the
code-checking mechanism of MD software packages to facilitate the
detection of such bugs. The `physicalvalidation` package is currently
used in the automated code-testing facility of the GROMACS software
package, ensuring that every major releases passes a number of physical
sanity checks performed on selected representative systems before
shipping.

.. note:: We are always looking to enlarge our set of tests. If you are a
   MD user or developer and have suggestions for physical validity tests
   missing in this package, we would love to hear from you! Please
   consider getting in touch with us via our `github page`_.

Installation
============

The latest version is available at `github page`_. Once you downloaded
or cloned the repository, simply type
::

   python3 setup.py install

while being in the root directory of the downloaded package.

.. warning:: While backward compatibility with python 2.7 is a feature
   we plan to offer, it is currently not tested and most probably broken.
   This will be addressed in the coming weeks. (June 2017)

`examples/` folder
==================

The folder `examples/` contains an example script, `example.py`, as well
as illustrative simulation results. The remaining of the user guide
explains the example script step-by-step, thereby introducing the
functionality of the package by analyzing the provided simulation results.
All code examples in the following sections assume that the
executing script is located in the `examples/` folder.


Simulation data
===============

The data of simulations to be validated are best represented by objects
of the  :class:`.SimulationData` type. While lower-level functions accepting
bare arrays and numbers are available, the  :class:`.SimulationData` objects
combine ease-of-use and higher stability in form of input testing.

The  :class:`.SimulationData` objects are consisting of information about the
system. This information is collected in objects of different classes, namely

* :obj:`.SimulationData.ensemble` of type :class:`.EnsembleData`:
  Information on the sampled ensemble.
* :obj:`.SimulationData.units` of type :class:`.UnitData`:
  Information on the units used by the simulation program.
* :obj:`.SimulationData.topology` of type :class:`.TopologyData`:
  Information on the topology of the system.
* :obj:`.SimulationData.observables` of type :class:`.ObservableData`:
  Trajectories of observables along the simulation.
* :obj:`.SimulationData.trajectory` of type :class:`.TrajectoryData`:
  Position / velocity / force trajectories along the simulation.

The :class:`.SimulationData` objects can either be constructed
directly from arrays and numbers, or (partially) automatically via parsers.

To facilitate the use of the physical validation suite, simulation results
generated by selected software packages can be automatically created by
:class:`.Parser` objects. The currently supported MD packages are:

* GROMACS: :class:`.GromacsParser`

Package-specific parsers are subclasses of :class:`.Parser`, and need to
redefine the :func:`.Parser.get_simulation_data` returning a
:class:`.SimulationData` object.

.. note:: Currently, the GROMACS parser
   automatically creates the :obj:`.SimulationData.units`,
   :obj:`.SimulationData.observables` and :obj:`.SimulationData.trajectory`
   parts of the object, but requires the user to create a
   :class:`.EnsembleData` and a :class:`.TopologyData` by hand.

.. note:: We are looking to enlarge the collection of parsers to make the
   use of the package as convenient as possible for as many users as
   possible. If your MD program of choice is not supported (yet), please
   consider either writing your own parser and contribute it by creating
   a pull request on the project's `github page`_, or contacting us to
   let us know about your needs and ideally help us getting a fitting
   parser out soon.

.. _example_sec_1:

Examples
--------
The subfolders of `examples/` contain MD simulation result files.
Specifically, the folder `nh1` contains the following GROMACS files (for
size reasons, no trajectory files are included in the distribution):

* `start.gro`: the starting configuration, containing 900 three-site
  water molecules
* `water.top`: the topology of a (flexible) water molecule
* `water.mdp`: the GROMACS input file
* `water.gro`: the end configuration
* `water.edr`: the resulting (binary) energy file

The simulation was ran at constant volume using a Nose-Hoover thermostat
to keep the temperature around its target value. To create a simulation
data object, first the relevant packages and modules are imported:
::

   import numpy as np
   from physicalvalidation.data.gromacs_parser import GromacsParser
   from physicalvalidation.data.simulation_data import TopologyData, EnsembleData

Currently, the GROMACS parser cannot create the topological data.
As there are 900 3-site molecules in the system, the number of atoms is 2700,
and the number of constraints is zero since the water was simulated with flexible
bonds. Without bond constraints, the only reduction of degrees of freedom is due to
the enforced removal of the center-of-mass translation. Finally, the molecule index is denoting
the first atom of each molecule, and is hence the vector `[0, 3, 6, ...]`, while
the number of constraints per molecule is zero.
Creating the toplogical data by hand therefore looks something like this:
::

   topo = TopologyData()
   topo.natoms = 2700
   topo.masses = np.array([15.99940, 1.00800, 1.00800]*900)
   topo.nconstraints = 0
   topo.ndof_total = 2700*3 - 3
   topo.ndof_reduction_tra = 3
   topo.ndof_reduction_rot = 0
   topo.molecule_idx = np.arange(0, 2700, 3)
   topo.nconstraints_per_molecule = np.zeros(900)


The sampled ensemble is canonical (NVT). The side length of the cubic box is
3.01125 nm, while the target temperature of the Nose-Hoover thermostat was set
to 300 K.
::

   NVT_300 = EnsembleData('NVT', natoms=2700, volume=3.01125**3, temperature=300)

A parser is created by giving the path to a GROMACS executable.
::

   parser = GromacsParser(exe='/path/to/gmx')

The simulation data is then created by requesting a :class:`.SimulationData`
object from the created parser, giving the created ensemble and topological
information as input, as well as pointers to energy and position trajectories.
Lastly, also the used time step can be given, :math:`\Delta t = 0.0005 ps` in
this case.
::

   nh1_data = parser.get_simulation_data(ensemble=NVT_300, topology=topo,
                                         edr='nh1/water.edr',
                                         gro='nh1/water.gro',
                                         dt=0.0005)

.. note:: Generally, the tests only require a subset of the data to be
   set. For example, testing for the correct ensemble of the potential
   energy does not require a position trajectory. As long as the required
   pieces of information are available, if is hence not necessary to fill
   all data structures of the `SimulationData` object.
   Consequently, all inputs of the `get_simulation_data` function of the
   parser are optional.


Kinetic energy validation
=========================
Kinetic energy tests include testing the likelihood of a trajectory
originating from a Maxwell-Boltzmann distribution and validating the
temperature equipartition between groups of degrees of freedom. For
details on the employed algorithms, please check the respective
function documentations.

Functions
---------
*Maxwell-Boltzmann ensemble validation:*
:func:`physicalvalidation.kineticenergy.mb_ensemble`


*Equipartition validation:*
:func:`physicalvalidation.kineticenergy.equipartition`

Examples
--------
Using the data structure created in :ref:`example_sec_1`, the kinetic
energy ensemble can be validated as follows:
::

   from physicalvalidation import kineticenergy

   kineticenergy.mb_ensemble(nh1_data,
                             alpha=0.05,
                             verbose=True)

This will yield the following result, indicating that under the chosen
confidence (:math:`\alpha=0.05`), the null-hypothesis that the energy
is Maxwell-Boltzmann distributed stands:
::

   Kolmogorov-Smirnov test result: p = 0.742541
   Null hypothesis: Kinetic energy is Maxwell-Boltzmann distributed
   Confidence alpha = 0.050000
   Result: Hypothesis stands

In folder `ber1`, the results of a very similar simulation are
stored. The only difference between the results in `nh1` and `ber1` is
that the first was performed at with a Nose-Hoover thermostat, while
the latter was performed using a Berendsen thermostat. Creating a second
simulation data structure only requires changing the path to the
simulation results:
::

   ber1_data = parser.get_simulation_data(ensemble=NVT_300, topology=topo,
                                          edr='ber1/water.edr',
                                          gro='ber1/water.gro',
                                          dt=0.0005)

Unsurprisingly, for these results, the hypothesis of a Maxwell-Boltzmann
distribution is largely rejected:
::

   kineticenergy.mb_ensemble(ber1_data,
                             alpha=0.05,
                             verbose=True)

yields
::

   Kolmogorov-Smirnov test result: p = 0.000000
   Null hypothesis: Kinetic energy is Maxwell-Boltzmann distributed
   Confidence alpha = 0.050000
   Result: Hypothesis rejected

.. todo:: Equipartition example

Ensemble validation
===================
As the distribution of configurational quantities like the potential
energy :math:`U`, the volume :math:`V` or the chemical potential
:math:`\mu` are in general not known analytically, testing the likelihood
of a trajectory sampling a given ensemble is less straightforward than
for the kinetic energy. However, generally, the ratio of the probability
distribution between samplings of the same ensemble at different state
points (e.g. at different temperatures, different pressures) is known
[Shirts2013]_.
Providing two simulations at different state points therefore allows a
validation of the sampled ensemble.

Note that the ensemble validation function is automatically inferring the
correct test based on the simulation that are given as input.

.. [Shirts2013] Shirts, M.R.
   "Simple Quantitative Tests to Validate Sampling from Thermodynamic Ensembles",
   J. Chem. Theory Comput., 2013, 9 (2), pp 909â€“926,
   http://dx.doi.org/10.1021/ct300688p

Functions
---------
:func:`physicalvalidation.ensemble.check`

Examples
--------
To validate the ensemble generated by the Nose-Hoover-thermostated
simulation in folder `nh1`, a second simulation at different
temperature (but otherwise identical setup) is necessary. The results
of a second simulation at 310K can be found in folder `nh2`.
After creating the data structure (using a different ensemble object),
the ensemble validation is then done as
::

   NVT_310 = EnsembleData('NVT', natoms=2700, volume=3.01125**3, temperature=310)
   nh2_data = parser.get_simulation_data(ensemble=NVT_310, topology=topo,
                                         edr='nh2/water.edr',
                                         gro='nh2/water.gro',
                                         dt=0.0005)


   from physicalvalidation import ensemble
   ensemble.check(nh1_data, nh2_data, total_energy=False)

The choice whether the total energy is chosen for the comparison or
only the potential energy (`total_energy=False`), is of lesser
importance in this case, as the kinetic energy does have the correct
distribution, as can be tested separately using the `kineticenergy`
module. The commands listed above will print results from different
analysis, including linear fit and maximum-likelihood analysis of
with both analytical and bootstrapped error estimate. As an example,
the output of the bootstrapped maximum-likelihood analysis looks like
::

   ---------------------------------------------
        Maximum Likelihood Analysis
   ---------------------------------------------
        df = -132.78305 +/- 2.01254
   ---------------------------------------------
        Estimated slope       vs.   True slope
   ---------------------------------------------
      0.012934 +/-    0.000196  |     0.012933
   ---------------------------------------------

   (That's 0.01 quantiles from true slope=0.012933, FYI.)

   ---------------------------------------------
    True dT =  10.000, Eff. dT =  10.001+/-0.152
   ---------------------------------------------

This indicates a nearly perfect ratio between the two distributions
and hence confirms that the expected NVT ensemble is sampled.

The same analysis can be applied for the simulation using Berendsen
thermostat. In analogy to the Nose-Hoover example, a second simulation
at higher temperature can be found in folder `ber2`, and the
analysis is called using
::

   ber2_data = parser.get_simulation_data(ensemble=NVT_310, topology=topo,
                                          edr='ber2/water.edr',
                                          gro='ber2/water.gro',
                                          dt=0.0005)
   ensemble.check(ber1_data, ber2_data, total_energy=False)

The output of the bootstrapped maximum-likelihood analysis now reads
::

   ---------------------------------------------
        Maximum Likelihood Analysis
   ---------------------------------------------
        df = 774.26128 +/- 18.27361
   ---------------------------------------------
        Estimated slope       vs.   True slope
   ---------------------------------------------
      0.022078 +/-    0.000520  |     0.012933
   ---------------------------------------------

   (That's 17.58 quantiles from true slope=0.012933, FYI.)
   (Ouch!)
   ---------------------------------------------
    True dT =  10.000, Eff. dT =  17.071+/-0.402
   ---------------------------------------------

This results indicate a large deviations form the expected ratio
between the distributions at different temperatures.

The test for NPT ensemble is done in analogy - the two simulations
can have been performed at different temperature (check of the
relative enthalpy distributions), at different pressure (check of
the relative volume distributions), or varying both state points
(two-dimensional energy-volume distributions).

Integrator validation
=====================
A simplectic integrator can be shown to conserve a constant of motion
(such as the energy in a microcanonical simulation) up to a fluctuation
depending on the integration time step chosen. Comparing two or more
constant-of-motion trajectories realized using different timesteps (but
otherwise unchanged simulation parameters) allows to check the
simplecticity of the integration. Note that lack of simplecticity does not
necessarily imply an error in the integration algorithm, it can also hint
at physical violations in other parts of the model, such as non-continuous
potential functions, unprecise handling of constraints, etc.

Functions
---------
:func:`physicalvalidation.integrator.convergence`

Examples
--------
Folder `nh1_dt` contains the results of a simulation identical to
`nh1`, but performed at halt the time step. The data structure is created
in analogy:
::

   nh1_dt_data = parser.get_simulation_data(ensemble=NVT_300, topology=topo,
                                            edr='nh1/water.edr',
                                            gro='nh1/water.gro',
                                            dt=0.00025)

The convergence of the integrator is best tested with several simulations
with gradually decreasing time step. For the sake of keeping the package
size reasonably small, two simulations will have to suffice to show the
convergence testing concept here:
::

   from physicalvalidation import integrator
   integrator.convergence([nh1_data, nh1_dt_data], verbose=True, tol=0.1)

This call generates the following output:
::

   -----------------------------------------------------------------
           dt        avg       rmsd      slope         ratio
                                                     dt^2       rmsd
   -----------------------------------------------------------------
       0.0005  -24823.60   9.39e+01   3.25e-02         --         --
      0.00025  -25003.13   4.39e+01   1.52e-02       4.00       2.14
   -----------------------------------------------------------------

The output of the function first lists the timestep, the average value of
the constant of motion, and its RMSD during the simulation. The fourth
column gives the measured slope of the constant of motion - a high value here
indicates a strong drift and hence a problem in the integrator. Even without
strong drift, as in the current situation, a large deviation in the ratio
between the rmsd values compared to the ratio between the timestep indicates
a problem in the integrator.

The reason for a failure of this test might not always be intuitively clear,
as many components play into the integrator convergence - the integrator
algorithm itself, but also the interaction function (e.g. non-continuous
cut-off) or the numerical precision of the floating point operations. It is
therefore mainly a tool for developers to detect bugs.

.. todo:: I'll add a more pedagogical example here tomorrow, if I find the
   time. I am actually not sure why it's failing in this case, but this is
   something to investigate later.

.. _`github page`: https://github.com/shirtsgroup/physical-validation

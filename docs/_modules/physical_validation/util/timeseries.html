

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>physical_validation.util.timeseries &mdash; physical_validation 0.9b documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="physical_validation 0.9b documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> physical_validation
          

          
          </a>

          
            
            
              <div class="version">
                0.9b
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#examples-folder"><cite>examples/</cite> folder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#simulation-data">Simulation data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#kinetic-energy-validation">Kinetic energy validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#ensemble-validation">Ensemble validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html#integrator-validation">Integrator Validation</a></li>
</ul>
<p class="caption"><span class="caption-text">Data format and parsers:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../parsers.html"><code class="docutils literal"><span class="pre">SimulationData</span></code> objects and parsers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parsers.html#data-contained-in-simulationdata-objects">Data contained in <code class="docutils literal"><span class="pre">SimulationData</span></code> objects</a></li>
</ul>
<p class="caption"><span class="caption-text">Package reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../physical_validation.html">physical_validation package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physical_validation.data.html">physical_validation.data subpackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../physical_validation.util.html">physical_validation.util subpackage</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">physical_validation</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>physical_validation.util.timeseries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for physical_validation.util.timeseries</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/local/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for extracting uncorrelated samples from correlated timeseries data.</span>

<span class="sd">This module provides various tools that allow one to examine the correlation functions and</span>
<span class="sd">integrated autocorrelation times in correlated timeseries data, compute statistical inefficiencies,</span>
<span class="sd">and automatically extract uncorrelated samples for data analysis.</span>

<span class="sd">REFERENCES</span>

<span class="sd">[1] Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states.</span>
<span class="sd">J. Chem. Phys. 129:124105, 2008</span>
<span class="sd">http://dx.doi.org/10.1063/1.2978177</span>

<span class="sd">[2] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted</span>
<span class="sd">histogram analysis method for the analysis of simulated and parallel tempering simulations.</span>
<span class="sd">JCTC 3(1):26-41, 2007.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># COPYRIGHT NOTICE</span>
<span class="c1">#</span>
<span class="c1"># Written by John D. Chodera &lt;jchodera@gmail.com&gt; and Michael R. Shirts &lt;mrshirts@gmail.com&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2007 The Regents of the University of California.  All Rights Reserved.</span>
<span class="c1"># Portions of this software are Copyright (c) 2007 Stanford University and Columbia University.</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it under the terms of</span>
<span class="c1"># the GNU General Public License as published by the Free Software Foundation; either version 2</span>
<span class="c1"># of the License, or (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;</span>
<span class="c1"># without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1"># See the GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License along with this program;</span>
<span class="c1"># if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,</span>
<span class="c1"># Boston, MA  02110-1301, USA.</span>
<span class="c1">#=============================================================================================</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># TODO</span>
<span class="c1"># * Implement unit tests that generate timeseries with various levels of Gaussian correlation to test all methods.</span>
<span class="c1"># * Add Zwanzig procedure for estimating statistical uncertainties in correlation functions</span>
<span class="c1"># (by making Gaussian process assumptions).</span>
<span class="c1">#=============================================================================================</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># VERSION CONTROL INFORMATION</span>
<span class="c1">#=============================================================================================</span>


<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2.0beta&quot;</span>
<span class="n">__authors__</span> <span class="o">=</span> <span class="s2">&quot;Michael R. Shirts and John D. Chodera.&quot;</span>
<span class="n">__licanse__</span> <span class="o">=</span> <span class="s2">&quot;GPL 2.0&quot;</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># IMPORTS</span>
<span class="c1">#=============================================================================================</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> 
<span class="kn">import</span> <span class="nn">numpy.linalg</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># Exception class.</span>
<span class="c1">#=============================================================================================</span>

<div class="viewcode-block" id="ParameterError"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.ParameterError">[docs]</a><span class="k">class</span> <span class="nc">ParameterError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;An error in the input parameters has been detected.</span>

<span class="sd">  &quot;&quot;&quot;</span></div>

<span class="c1">#=============================================================================================</span>
<span class="c1"># Issue warning on import.</span>
<span class="c1">#=============================================================================================</span>

<span class="n">LongWarning</span> <span class="o">=</span> <span class="s2">&quot;Warning: If the inherent timescales of the system are long compared to those being analyzed, this statistical inefficiency may be an underestimate.  The estimate presumes the use of many statistically independent samples.  Tests should be performed to assess whether this condition is satisfied.   Be cautious in the interpretation of the data.&quot;</span>

<span class="c1"># sys.stderr.write(LongWarning + &#39;\n&#39;)</span>

<span class="c1">#=============================================================================================</span>
<span class="c1"># METHODS</span>
<span class="c1">#=============================================================================================</span>

<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="statisticalInefficiency"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.statisticalInefficiency">[docs]</a><span class="k">def</span> <span class="nf">statisticalInefficiency</span><span class="p">(</span><span class="n">A_n</span><span class="p">,</span> <span class="n">B_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mintime</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the (cross) statistical inefficiency of (two) timeseries.</span>

<span class="sd">  REQUIRED ARGUMENTS  </span>
<span class="sd">    A_n (numpy array) - A_n[n] is nth value of timeseries A.  Length is deduced from vector.</span>

<span class="sd">  OPTIONAL ARGUMENTS</span>
<span class="sd">    B_n (numpy array) - B_n[n] is nth value of timeseries B.  Length is deduced from vector.</span>
<span class="sd">       If supplied, the cross-correlation of timeseries A and B will be estimated instead of the</span>
<span class="sd">       autocorrelation of timeseries A.  </span>
<span class="sd">    fast (boolean) - if True, will use faster (but less accurate) method to estimate correlation</span>
<span class="sd">       time, described in Ref. [1] (default: False)</span>
<span class="sd">    mintime (int) - minimum amount of correlation function to compute (default: 3)</span>
<span class="sd">       The algorithm terminates after computing the correlation time out to mintime when the</span>
<span class="sd">       correlation function furst goes negative.  Note that this time may need to be increased</span>
<span class="sd">       if there is a strong initial negative peak in the correlation function.</span>

<span class="sd">  RETURNS</span>
<span class="sd">    g is the estimated statistical inefficiency (equal to 1 + 2 tau, where tau is the correlation time).</span>
<span class="sd">       We enforce g &gt;= 1.0.</span>

<span class="sd">  NOTES </span>
<span class="sd">    The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.</span>
<span class="sd">    The fast method described in Ref [1] is used to compute g.</span>

<span class="sd">  REFERENCES  </span>
<span class="sd">    [1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted</span>
<span class="sd">    histogram analysis method for the analysis of simulated and parallel tempering simulations.</span>
<span class="sd">    JCTC 3(1):26-41, 2007.</span>

<span class="sd">  EXAMPLES</span>

<span class="sd">  Compute statistical inefficiency of timeseries data with known correlation time.  </span>

<span class="sd">  &gt;&gt;&gt; import testsystems</span>
<span class="sd">  &gt;&gt;&gt; A_n = testsystems.generateCorrelatedTimeseries(N=100000, tau=5.0)</span>
<span class="sd">  &gt;&gt;&gt; g = statisticalInefficiency(A_n, fast=True)</span>
<span class="sd">  </span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Create numpy copies of input arguments.</span>
  <span class="n">A_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">B_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  
    <span class="n">B_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B_n</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">B_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_n</span><span class="p">)</span> 
  
  <span class="c1"># Get the length of the timeseries.</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">size</span>

  <span class="c1"># Be sure A_n and B_n have the same dimensions.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">A_n</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;A_n and B_n must have same dimensions.&#39;</span><span class="p">)</span>

  <span class="c1"># Initialize statistical inefficiency estimate with uncorrelated value.</span>
  <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>
    
  <span class="c1"># Compute mean of each timeseries.</span>
  <span class="n">mu_A</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
  <span class="n">mu_B</span> <span class="o">=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

  <span class="c1"># Make temporary copies of fluctuation from mean.</span>
  <span class="n">dA_n</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu_A</span>
  <span class="n">dB_n</span> <span class="o">=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu_B</span>

  <span class="c1"># Compute estimator of covariance of (A,B) using estimator that will ensure C(0) = 1.</span>
  <span class="n">sigma2_AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">dA_n</span> <span class="o">*</span> <span class="n">dB_n</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="c1"># standard estimator to ensure C(0) = 1</span>

  <span class="c1"># Trap the case where this covariance is zero, and we cannot proceed.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">sigma2_AB</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ParameterException</span><span class="p">(</span><span class="s1">&#39;Sample covariance sigma_AB^2 = 0 -- cannot compute statistical inefficiency&#39;</span><span class="p">)</span>

  <span class="c1"># Accumulate the integrated correlation time by computing the normalized correlation time at</span>
  <span class="c1"># increasing values of t.  Stop accumulating if the correlation function goes negative, since</span>
  <span class="c1"># this is unlikely to occur unless the correlation function has decayed to the point where it</span>
  <span class="c1"># is dominated by noise and indistinguishable from zero.</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># compute normalized fluctuation correlation function at time t</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">dA_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span><span class="o">*</span><span class="n">dB_n</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="n">dB_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span><span class="o">*</span><span class="n">dA_n</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma2_AB</span><span class="p">)</span>
    <span class="c1"># Terminate if the correlation function has crossed zero and we&#39;ve computed the correlation</span>
    <span class="c1"># function at least out to &#39;mintime&#39;.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">C</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">mintime</span><span class="p">):</span>
      <span class="k">break</span>
    
    <span class="c1"># Accumulate contribution to the statistical inefficiency.</span>
    <span class="n">g</span> <span class="o">+=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">increment</span><span class="p">)</span>
    <span class="c1"># Increment t and the amount by which we increment t.</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># Increase the interval if &quot;fast mode&quot; is on.</span>
    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span> <span class="n">increment</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># g must be at least unity</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span> <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>
   
  <span class="c1"># Return the computed statistical inefficiency.</span>
  <span class="k">return</span> <span class="n">g</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="statisticalInefficiencyMultiple"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.statisticalInefficiencyMultiple">[docs]</a><span class="k">def</span> <span class="nf">statisticalInefficiencyMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_correlation_function</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimate the statistical inefficiency from multiple stationary timeseries (of potentially differing lengths).</span>

<span class="sd">  REQUIRED ARGUMENTS  </span>
<span class="sd">    A_kn (Python list of numpy arrays) - A_kn[k] is the kth timeseries, and A_kn[k][n] is nth value of timeseries k.  Length is deduced from arrays.</span>

<span class="sd">  OPTIONAL ARGUMENTS  </span>
<span class="sd">    fast can be set to True to give a less accurate but very quick estimate (default False)</span>
<span class="sd">    return_correlation_function - if True, will also return estimates of normalized fluctuation correlation function that were computed (default: False)</span>

<span class="sd">  RETURNS</span>
<span class="sd">    g is the statistical inefficiency (equal to 1 + 2 tau, where tau is the integrated autocorrelation time).</span>
<span class="sd">    Ct (list of tuples) - Ct[n] = (t, C) with time t and normalized correlation function estimate C is returned as well if return_correlation_function is set to True</span>
<span class="sd">    </span>
<span class="sd">  NOTES </span>
<span class="sd">    The autocorrelation of the timeseries is used to compute the statistical inefficiency.</span>
<span class="sd">    The normalized fluctuation autocorrelation function is computed by averaging the unnormalized raw correlation functions.</span>
<span class="sd">    The fast method described in Ref [1] is used to compute g.</span>

<span class="sd">  REFERENCES  </span>
<span class="sd">    [1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted</span>
<span class="sd">    histogram analysis method for the analysis of simulated and parallel tempering simulations.</span>
<span class="sd">    JCTC 3(1):26-41, 2007.</span>

<span class="sd">  EXAMPLES</span>

<span class="sd">  Estimate statistical efficiency from multiple timeseries of different lengths.</span>

<span class="sd">  &gt;&gt;&gt; import testsystems</span>
<span class="sd">  &gt;&gt;&gt; N_k = [1000, 2000, 3000, 4000, 5000]</span>
<span class="sd">  &gt;&gt;&gt; tau = 5.0 # exponential relaxation time</span>
<span class="sd">  &gt;&gt;&gt; A_kn = [ testsystems.generateCorrelatedTimeseries(N=N, tau=tau) for N in N_k ]</span>
<span class="sd">  &gt;&gt;&gt; g = statisticalInefficiencyMultiple(A_kn)</span>

<span class="sd">  Also return the values of the normalized fluctuation autocorrelation function that were computed.</span>

<span class="sd">  &gt;&gt;&gt; [g, Ct] = statisticalInefficiencyMultiple(A_kn, return_correlation_function=True)</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Convert A_kn into a list of arrays if it is not in this form already.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="n">A_kn_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">A_kn</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>      
      <span class="n">A_kn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_kn</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="p">[</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_kn</span><span class="o">.</span><span class="n">shape</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">A_kn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">A_kn</span> <span class="o">=</span> <span class="n">A_kn_list</span>
      
  <span class="c1"># Determine number of timeseries.</span>
  <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span>

  <span class="c1"># Get the length of each timeseries.</span>
  <span class="n">N_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

  <span class="c1"># Compute average timeseries length.</span>
  <span class="n">Navg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N_k</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

  <span class="c1"># Determine total number of samples.</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">N_k</span><span class="p">)</span>

  <span class="c1"># Initialize statistical inefficiency estimate with uncorrelated value.</span>
  <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>
    
  <span class="c1"># Compute sample mean.</span>
  <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">+=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">mu</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
  
  <span class="c1"># Construct and store fluctuation timeseries.</span>
  <span class="n">dA_kn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">dA_n</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu</span>
    <span class="n">dA_kn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dA_n</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

  <span class="c1"># Compute sample variance from mean of squared fluctuations, to ensure that C(0) = 1.</span>
  <span class="n">sigma2</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">sigma2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dA_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">sigma2</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
  
  <span class="c1"># Initialize statistical inefficiency estimate with uncorrelated value.</span>
  <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>

  <span class="c1"># Initialize storage for correlation function.</span>
  <span class="n">Ct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># Ct[n] is a tuple (t, C) of the time lag t and estimate of normalized fluctuation correlation function C</span>
    
  <span class="c1"># Accumulate the integrated correlation time by computing the normalized correlation time at</span>
  <span class="c1"># increasing values of t.  Stop accumulating if the correlation function goes negative, since</span>
  <span class="c1"># this is unlikely to occur unless the correlation function has decayed to the point where it</span>
  <span class="c1"># is dominated by noise and indistinguishable from zero.</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span>  
  <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">N_k</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># compute unnormalized correlation function</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span> <span class="k">continue</span> <span class="c1"># skip trajectory if lag time t is greater than its length</span>
      <span class="n">dA_n</span> <span class="o">=</span> <span class="n">dA_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># retrieve trajectory</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">dA_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span> <span class="o">*</span> <span class="n">dA_n</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
      <span class="n">numerator</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># accumulate contribution from trajectory k</span>
      <span class="n">denominator</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1"># count how many overlapping time segments we&#39;ve included</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

    <span class="c1"># compute normalized fluctuation correlation function at time t</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">/</span> <span class="n">sigma2</span>
    <span class="c1">#print &quot;C[%5d] = %16f (%16f / %16f)&quot; % (t, C, numerator, denominator)    </span>

    <span class="c1"># Store estimate of correlation function.</span>
    <span class="n">Ct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Terminate if the correlation function has crossed zero.</span>
    <span class="c1"># Note that we&#39;ve added a hack (t &gt; 10) condition to avoid terminating too early in correlation functions that have a strong negative peak at </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">C</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">):</span>
      <span class="k">break</span>
  
    <span class="c1"># Accumulate contribution to the statistical inefficiency.</span>
    <span class="n">g</span> <span class="o">+=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">Navg</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">increment</span><span class="p">)</span>

    <span class="c1"># Increment t and the amount by which we increment t.</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="c1"># Increase the interval if &quot;fast mode&quot; is on.</span>
    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span> <span class="n">increment</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># g must be at least unity</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span> <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>

  <span class="c1"># Return statistical inefficency and correlation function estimate, if requested.</span>
  <span class="k">if</span> <span class="n">return_correlation_function</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Ct</span><span class="p">)</span>

  <span class="c1"># Return the computed statistical inefficiency.</span>
  <span class="k">return</span> <span class="n">g</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="integratedAutocorrelationTime"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.integratedAutocorrelationTime">[docs]</a><span class="k">def</span> <span class="nf">integratedAutocorrelationTime</span><span class="p">(</span><span class="n">A_n</span><span class="p">,</span> <span class="n">B_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mintime</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimate the integrated autocorrelation time.</span>

<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiency</span><span class="p">(</span><span class="n">A_n</span><span class="p">,</span> <span class="n">B_n</span><span class="p">,</span> <span class="n">fast</span><span class="p">,</span> <span class="n">mintime</span><span class="p">)</span>
  <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
  <span class="k">return</span> <span class="n">tau</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="integratedAutocorrelationTimeMultiple"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.integratedAutocorrelationTimeMultiple">[docs]</a><span class="k">def</span> <span class="nf">integratedAutocorrelationTimeMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimate the integrated autocorrelation time from multiple timeseries.</span>

<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiencyMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">fast</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
  <span class="k">return</span> <span class="n">tau</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="normalizedFluctuationCorrelationFunction"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.normalizedFluctuationCorrelationFunction">[docs]</a><span class="k">def</span> <span class="nf">normalizedFluctuationCorrelationFunction</span><span class="p">(</span><span class="n">A_n</span><span class="p">,</span> <span class="n">B_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N_max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the normalized fluctuation (cross) correlation function of (two) stationary timeseries.</span>

<span class="sd">  C(t) = (&lt;A(t) B(t)&gt; - &lt;A&gt;&lt;B&gt;) / (&lt;AB&gt; - &lt;A&gt;&lt;B&gt;)</span>

<span class="sd">  This may be useful in diagnosing odd time-correlations in timeseries data.</span>

<span class="sd">  REQUIRED ARGUMENTS  </span>
<span class="sd">    A_n[n] is nth value of timeseries A.  Length is deduced from vector.</span>
<span class="sd">    B_n[n] is nth value of timeseries B.  Length is deduced from vector.</span>

<span class="sd">  OPTIONAL ARGUMENTS</span>
<span class="sd">    N_max - if specified, will only compute correlation function out to time lag of N_max</span>

<span class="sd">  RETURNS</span>
<span class="sd">    C_n[n] is the normalized fluctuation auto- or cross-correlation function for timeseries A(t) and B(t).</span>

<span class="sd">  NOTES </span>
<span class="sd">    The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.</span>
<span class="sd">    This procedure may be slow.</span>
<span class="sd">    The statistical error in C_n[n] will grow with increasing n.  No effort is made here to estimate the uncertainty.</span>

<span class="sd">  REFERENCES  </span>
<span class="sd">    [1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted</span>
<span class="sd">    histogram analysis method for the analysis of simulated and parallel tempering simulations.</span>
<span class="sd">    JCTC 3(1):26-41, 2007.</span>

<span class="sd">  EXAMPLES</span>

<span class="sd">  Estimate normalized fluctuation correlation function.</span>

<span class="sd">  &gt;&gt;&gt; import testsystems</span>
<span class="sd">  &gt;&gt;&gt; A_t = testsystems.generateCorrelatedTimeseries(N=10000, tau=5.0)</span>
<span class="sd">  &gt;&gt;&gt; C_t = normalizedFluctuationCorrelationFunction(A_t, N_max=25)</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># If B_n is not specified, set it to be identical to A_n.</span>
  <span class="k">if</span> <span class="n">B_n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">B_n</span> <span class="o">=</span> <span class="n">A_n</span>

  <span class="c1"># Create numpy copies of input arguments.</span>
  <span class="n">A_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_n</span><span class="p">)</span>
  <span class="n">B_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B_n</span><span class="p">)</span>

  <span class="c1"># Get the length of the timeseries.</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">size</span>

  <span class="c1"># Set maximum time to compute correlation functon for.</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">N_max</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N_max</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">N_max</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>

  <span class="c1"># Be sure A_n and B_n have the same dimensions.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">A_n</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;A_n and B_n must have same dimensions.&#39;</span><span class="p">)</span>

  <span class="c1"># Initialize statistical inefficiency estimate with uncorrelated value.</span>
  <span class="n">g</span> <span class="o">=</span> <span class="mf">1.0</span>
    
  <span class="c1"># Compute means and variance.</span>
  <span class="n">mu_A</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
  <span class="n">mu_B</span> <span class="o">=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

  <span class="c1"># Make temporary copies at high precision with means subtracted off.</span>
  <span class="n">dA_n</span> <span class="o">=</span> <span class="n">A_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu_A</span>
  <span class="n">dB_n</span> <span class="o">=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">mu_B</span>

  <span class="c1"># sigma2_AB = sum((A_n-mu_A) * (B_n-mu_B)) / (float(N)-1.0) # unbiased estimator</span>
  <span class="n">sigma2_AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">dA_n</span> <span class="o">*</span> <span class="n">dB_n</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="c1"># standard estimator to ensure C(0) = 1</span>
  <span class="k">if</span><span class="p">(</span><span class="n">sigma2_AB</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ParameterException</span><span class="p">(</span><span class="s1">&#39;Sample covariance sigma_AB^2 = 0 -- cannot compute statistical inefficiency&#39;</span><span class="p">)</span>

  <span class="c1"># allocate storage for normalized fluctuation correlation function</span>
  <span class="n">C_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_max</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  

  <span class="c1"># Compute normalized correlation funtion.</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># compute normalized fluctuation correlation function at time t</span>
    <span class="n">C_n</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">dA_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span><span class="o">*</span><span class="n">dB_n</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="n">dB_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span><span class="o">*</span><span class="n">dA_n</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma2_AB</span><span class="p">)</span>

  <span class="c1"># Return the computed correlation function</span>
  <span class="k">return</span> <span class="n">C_n</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="normalizedFluctuationCorrelationFunctionMultiple"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.normalizedFluctuationCorrelationFunctionMultiple">[docs]</a><span class="k">def</span> <span class="nf">normalizedFluctuationCorrelationFunctionMultiple</span><span class="p">(</span><span class="n">A_kn</span><span class="p">,</span> <span class="n">B_kn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the normalized fluctuation (cross) correlation function of (two) timeseries from multiple timeseries samples.</span>

<span class="sd">  C(t) = (&lt;A(t) B(t)&gt; - &lt;A&gt;&lt;B&gt;) / (&lt;AB&gt; - &lt;A&gt;&lt;B&gt;)</span>

<span class="sd">  This may be useful in diagnosing odd time-correlations in timeseries data.</span>

<span class="sd">  REQUIRED ARGUMENTS  </span>
<span class="sd">    A_kn (Python list of numpy arrays) - A_kn[k] is the kth timeseries, and A_kn[k][n] is nth value of timeseries k.  Length is deduced from arrays.</span>
<span class="sd">    B_kn (Python list of numpy arrays) - B_kn[k] is the kth timeseries, and B_kn[k][n] is nth value of timeseries k.  B_kn[k] must have same length as A_kn[k]</span>

<span class="sd">  OPTIONAL ARGUMENTS</span>
<span class="sd">    N_max - if specified, will only compute correlation function out to time lag of N_max</span>
<span class="sd">    suppress_warning - if we are calculating a lot of these, the warning could get a little annoying. Make it possible to suppress it, but don&#39;t make that the default.</span>

<span class="sd">  RETURNS</span>
<span class="sd">    C_n[n] is the normalized fluctuation auto- or cross-correlation function for timeseries A(t) and B(t).</span>

<span class="sd">  NOTES</span>
<span class="sd">    The same timeseries can be used for both A_n and B_n to get the autocorrelation statistical inefficiency.</span>
<span class="sd">    This procedure may be slow.</span>
<span class="sd">    The statistical error in C_n[n] will grow with increasing n.  No effort is made here to estimate the uncertainty.</span>

<span class="sd">  REFERENCES  </span>
<span class="sd">    [1] J. D. Chodera, W. C. Swope, J. W. Pitera, C. Seok, and K. A. Dill. Use of the weighted</span>
<span class="sd">    histogram analysis method for the analysis of simulated and parallel tempering simulations.</span>
<span class="sd">    JCTC 3(1):26-41, 2007.</span>

<span class="sd">  EXAMPLES</span>

<span class="sd">  Estimate a portion of the normalized fluctuation autocorrelation function from multiple timeseries of different length.</span>

<span class="sd">  &gt;&gt;&gt; import testsystems</span>
<span class="sd">  &gt;&gt;&gt; N_k = [1000, 2000, 3000, 4000, 5000]</span>
<span class="sd">  &gt;&gt;&gt; tau = 5.0 # exponential relaxation time</span>
<span class="sd">  &gt;&gt;&gt; A_kn = [ testsystems.generateCorrelatedTimeseries(N=N, tau=tau) for N in N_k ]</span>
<span class="sd">  &gt;&gt;&gt; C_n = normalizedFluctuationCorrelationFunctionMultiple(A_kn, N_max=25)</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># If B_kn is not specified, define it to be identical with A_kn.</span>
  <span class="k">if</span> <span class="n">B_kn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">B_kn</span> <span class="o">=</span> <span class="n">A_kn</span>  

  <span class="c1"># TODO: Change this to support other iterable types, like sets.</span>
  <span class="c1"># Make sure A_kn and B_kn are both lists</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B_kn</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;A_kn and B_kn must each be a list of numpy arrays.&quot;</span><span class="p">)</span>
  
  <span class="c1"># Ensure the same number of timeseries are stored in A_kn and B_kn.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B_kn</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;A_kn and B_kn must contain corresponding timeseries -- different numbers of timeseries detected in each.&quot;</span><span class="p">)</span>

  <span class="c1"># Determine number of timeseries stored.</span>
  <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A_kn</span><span class="p">)</span>  

  <span class="c1"># Ensure both observable trajectories in each timeseries are of the same length.</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">A_n</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">B_n</span> <span class="o">=</span> <span class="n">B_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">A_n</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">B_n</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A_kn and B_kn must contain corresponding timeseries -- lack of correspondence in timeseries lenghts detected.&quot;</span><span class="p">)</span>
  
  <span class="c1"># Get the length of each timeseries.</span>
  <span class="n">N_k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

  <span class="c1"># Determine total number of samples.</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">N_k</span><span class="p">)</span>

  <span class="c1"># Set maximum time to compute correlation functon for.</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">N_max</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N_max</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">N_k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">N_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">N_k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="c1"># Compute means.</span>
  <span class="n">mu_A</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">mu_B</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">mu_A</span> <span class="o">+=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">mu_B</span> <span class="o">+=</span> <span class="n">B_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">mu_A</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
  <span class="n">mu_B</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
  
  <span class="c1"># Compute fluctuation timeseries.</span>
  <span class="n">dA_kn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="n">dB_kn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">dA_n</span> <span class="o">=</span> <span class="n">A_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu_A</span>
    <span class="n">dB_n</span> <span class="o">=</span> <span class="n">B_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu_B</span>
    <span class="n">dA_kn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dA_n</span><span class="p">)</span>
    <span class="n">dB_kn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dB_n</span><span class="p">)</span>    

  <span class="c1"># Compute covariance.</span>
  <span class="n">sigma2_AB</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="n">sigma2_AB</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dA_kn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">dB_kn</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">sigma2_AB</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

  <span class="c1"># allocate storage for normalized fluctuation correlation function</span>
  <span class="n">C_n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_max</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  

  <span class="c1"># Accumulate the integrated correlation time by computing the normalized correlation time at</span>
  <span class="c1"># increasing values of t.  Stop accumulating if the correlation function goes negative, since</span>
  <span class="c1"># this is unlikely to occur unless the correlation function has decayed to the point where it</span>
  <span class="c1"># is dominated by noise and indistinguishable from zero.</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># compute unnormalized correlation function</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span> <span class="k">continue</span> <span class="c1"># skip this trajectory if t is longer than the timeseries</span>
      <span class="n">numerator</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dA_kn</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">:(</span><span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span> <span class="o">*</span> <span class="n">dB_kn</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">t</span><span class="p">:</span><span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
      <span class="n">denominator</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
    
    <span class="c1"># compute normalized fluctuation correlation function at time t</span>
    <span class="n">C</span> <span class="o">/=</span> <span class="n">sigma2_AB</span>

    <span class="c1"># Store correlation function.</span>
    <span class="n">C_n</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>

  <span class="c1"># Return the computed fluctuation correlation function.</span>
  <span class="k">return</span> <span class="n">C_n</span></div>
<span class="c1">#=============================================================================================</span>
<div class="viewcode-block" id="subsampleCorrelatedData"><a class="viewcode-back" href="../../../physical_validation.util.html#physical_validation.util.timeseries.subsampleCorrelatedData">[docs]</a><span class="k">def</span> <span class="nf">subsampleCorrelatedData</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conservative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Determine the indices of an uncorrelated subsample of the data.</span>

<span class="sd">  REQUIRED ARGUMENTS  </span>
<span class="sd">    A_t (T array) - A_t[t] is the t-th value of timeseries A(t).  Length is deduced from vector.</span>

<span class="sd">  OPTIONAL ARGUMENTS</span>
<span class="sd">    g (float) - if provided, the statistical inefficiency g is used to subsample the timeseries -- otherwise it will be computed (default: None)</span>
<span class="sd">    fast (logical) - fast can be set to True to give a less accurate but very quick estimate (default: False)</span>
<span class="sd">    conservative (logical) - if set to True, uniformly-spaced indices are chosen with interval ceil(g), where g is the statistical inefficiency.  Otherwise, indices are chosen non-uniformly with interval of approximately g in order to end up with approximately T/g total indices</span>
<span class="sd">    verbose (logical) - if True, some output is printed</span>

<span class="sd">  RETURNS  </span>
<span class="sd">    indices (list of int) - the indices of an uncorrelated subsample of the data</span>

<span class="sd">  NOTES</span>
<span class="sd">    The statistical inefficiency is computed with the function computeStatisticalInefficiency().</span>

<span class="sd">  TODO</span>
<span class="sd">    Instead of using regular stride, use irregular stride so more data can be fit in when g is non-integral.</span>

<span class="sd">  EXAMPLES</span>

<span class="sd">  Subsample a correlated timeseries to extract an effectively uncorrelated dataset.</span>

<span class="sd">  &gt;&gt;&gt; import testsystems</span>
<span class="sd">  &gt;&gt;&gt; A_t = testsystems.generateCorrelatedTimeseries(N=10000, tau=5.0) # generate a test correlated timeseries</span>
<span class="sd">  &gt;&gt;&gt; indices = subsampleCorrelatedData(A_t) # compute indices of uncorrelated timeseries</span>
<span class="sd">  &gt;&gt;&gt; A_n = A_t[indices] # extract uncorrelated samples</span>

<span class="sd">  Extract uncorrelated samples from multiple timeseries data from the same process.</span>

<span class="sd">  &gt;&gt;&gt; # Generate multiple correlated timeseries data of different lengths.</span>
<span class="sd">  &gt;&gt;&gt; T_k = [1000, 2000, 3000, 4000, 5000]</span>
<span class="sd">  &gt;&gt;&gt; K = len(T_k) # number of timeseries</span>
<span class="sd">  &gt;&gt;&gt; tau = 5.0 # exponential relaxation time</span>
<span class="sd">  &gt;&gt;&gt; A_kt = [ testsystems.generateCorrelatedTimeseries(N=T, tau=tau) for T in T_k ] # A_kt[k] is correlated timeseries k</span>
<span class="sd">  &gt;&gt;&gt; # Estimate statistical inefficiency from all timeseries data.</span>
<span class="sd">  &gt;&gt;&gt; g = statisticalInefficiencyMultiple(A_kt)</span>
<span class="sd">  &gt;&gt;&gt; # Count number of uncorrelated samples in each timeseries.</span>
<span class="sd">  &gt;&gt;&gt; N_k = numpy.array([ len(subsampleCorrelatedData(A_t, g=g)) for A_t in A_kt ]) # N_k[k] is the number of uncorrelated samples in timeseries k</span>
<span class="sd">  &gt;&gt;&gt; N = N_k.sum() # total number of uncorrelated samples</span>
<span class="sd">  &gt;&gt;&gt; # Subsample all trajectories to produce uncorrelated samples</span>
<span class="sd">  &gt;&gt;&gt; A_kn = [ A_t[subsampleCorrelatedData(A_t, g=g)] for A_t in A_kt ] # A_kn[k] is uncorrelated subset of trajectory A_kt[t]</span>
<span class="sd">  &gt;&gt;&gt; # Concatenate data into one timeseries.</span>
<span class="sd">  &gt;&gt;&gt; A_n = numpy.zeros([N], numpy.float32) # A_n[n] is nth sample in concatenated set of uncorrelated samples</span>
<span class="sd">  &gt;&gt;&gt; A_n[0:N_k[0]] = A_kn[0]</span>
<span class="sd">  &gt;&gt;&gt; for k in range(1,K): A_n[N_k[0:k].sum():N_k[0:k+1].sum()] = A_kn[k]</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># Create numpy copy of arrays.</span>
  <span class="n">A_t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_t</span><span class="p">)</span>

  <span class="c1"># Get the length of the timeseries.</span>
  <span class="n">T</span> <span class="o">=</span> <span class="n">A_t</span><span class="o">.</span><span class="n">size</span>

  <span class="c1"># Compute the statistical inefficiency for the timeseries.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing statistical inefficiency...&quot;</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">statisticalInefficiency</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">A_t</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;g = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">g</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
    <span class="c1"># Round g up to determine the stride we can use to pick out regularly-spaced uncorrelated samples.</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;conservative subsampling: using stride of </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">stride</span><span class="p">)</span>
    
    <span class="c1"># Assemble list of indices of uncorrelated snapshots.</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">stride</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># Choose indices as floor(n*g), with n = 0,1,2,..., until we run out of data.</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">g</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
      <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">g</span><span class="p">))</span>
      <span class="c1"># ensure we don&#39;t sample the same point twice</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
      <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;standard subsampling: using average stride of </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">g</span><span class="p">)</span>

  <span class="c1"># Number of samples in subsampled timeseries.</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The resulting subsampled set has </span><span class="si">%d</span><span class="s2"> samples (original timeseries had </span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

  <span class="c1"># Return the list of indices of uncorrelated snapshots.</span>
  <span class="k">return</span> <span class="n">indices</span></div>

<span class="c1">#=============================================================================================</span>
<span class="c1"># MAIN AND TESTS</span>
<span class="c1">#=============================================================================================</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
  <span class="kn">import</span> <span class="nn">doctest</span>
  <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Pascal T. Merz, Michael R. Shirts.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.9b',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>